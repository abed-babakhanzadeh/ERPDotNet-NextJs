
dotnet ef database update

docker compose up -d --build
docker-compose up -d
docker-compose up -d db redis

---------------------------------------------------
cd ERPDotNet/ERPDotNet.API  
dotnet watch run 
dotnet build --startup-project ERPDotNet.API
dotnet ef database update --project ERPDotNet.Infrastructure --startup-project ERPDotNet.API
dotnet ef migrations add AddWhereUsedFunction --project ERPDotNet.Infrastructure --startup-project ERPDotNet.API
---------------------------------------------------
cd erp-frontend
npm run dev


=========================================================================================
این کوئری را نباید روی خود ERP_DB اجرا کنید! باید روی دیتابیس پیش‌فرض (مثل postgres) کلیک راست کنید و Query Tool را باز کنید و آنجا اجرا کنید.

SELECT pg_terminate_backend(pg_stat_activity.pid)
FROM pg_stat_activity
WHERE pg_stat_activity.datname = 'ERP_DB' -- نام دیتابیس هدف
  AND pid <> pg_backend_pid(); -- این خط باعث می‌شود اتصال خودتان قطع نشود
=========================================================================================

۱. اجرای کوئری پاک‌سازی (Truncate All)
در pgAdmin، روی دیتابیس ERP_DB کلیک راست کنید و Query Tool را باز کنید. کد زیر را کپی و اجرا کنید. این کد تمام جداول موجود در اسکیماهای شما را پیدا کرده و خالی می‌کند (بدون حذف خود جداول):

DO $$ 
DECLARE 
    r RECORD;
BEGIN 
    -- غیرفعال کردن موقت تریگرها برای جلوگیری از خطاهای احتمالی
    SET session_replication_role = 'replica';

    FOR r IN (
        SELECT tablename, schemaname 
        FROM pg_tables 
        WHERE schemaname IN ('public', 'base', 'eng', 'security') -- لیست اسکیماهای پروژه شما
    ) LOOP 
        EXECUTE 'TRUNCATE TABLE "' || r.schemaname || '"."' || r.tablename || '" CASCADE;'; 
    END LOOP;

    -- برگرداندن تنظیمات به حالت عادی
    SET session_replication_role = 'origin';
END $$;


=========================================================================================

کوئری ساخت انکشن مصرف مواد:

CREATE OR REPLACE FUNCTION "get_where_used_recursive"(input_product_id INT)
RETURNS TABLE (
    "BomHeaderId" INT,
    "ProductId" INT,
    "Level" INT,
    "UsageType" TEXT,
    "Quantity" DECIMAL,
    "Path" TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE BOM_CTE AS (
        -- 1. Anchor Member: استفاده مستقیم
        SELECT 
            h."Id" AS "BomHeaderId",
            h."ProductId",
            1 AS "Level",
            'ماده اولیه' AS "UsageType",
            d."Quantity",
            CAST(h."ProductId" AS TEXT) AS "Path"
        FROM "eng"."bom_details" d
        -- اصلاح شد: BomHeaderId -> BOMHeaderId
        JOIN "eng"."bom_headers" h ON d."BOMHeaderId" = h."Id"
        WHERE d."ChildProductId" = input_product_id AND h."IsActive" = TRUE

        UNION ALL

        -- 1.1. Anchor Member: استفاده جایگزین
        SELECT 
            h."Id" AS "BomHeaderId",
            h."ProductId",
            1 AS "Level",
            'جایگزین' AS "UsageType",
            s."Factor" AS "Quantity",
            CAST(h."ProductId" AS TEXT) AS "Path"
        FROM "eng"."bom_substitutes" s
        -- اصلاح شد: BOMDetailId (معمولا EF همه را بزرگ می‌زند اگر در کلاس بزرگ باشد)
        JOIN "eng"."bom_details" d ON s."BOMDetailId" = d."Id"
        -- اصلاح شد: BomHeaderId -> BOMHeaderId
        JOIN "eng"."bom_headers" h ON d."BOMHeaderId" = h."Id"
        WHERE s."SubstituteProductId" = input_product_id AND h."IsActive" = TRUE

        UNION ALL

        -- 2. Recursive Member: سطوح بالاتر
        SELECT 
            h."Id" AS "BomHeaderId",
            h."ProductId",
            cte."Level" + 1,
            'ماده اولیه (غیرمستقیم)' AS "UsageType",
            d."Quantity",
            cte."Path" || '->' || CAST(h."ProductId" AS TEXT)
        FROM "eng"."bom_details" d
        -- اصلاح شد: BomHeaderId -> BOMHeaderId
        JOIN "eng"."bom_headers" h ON d."BOMHeaderId" = h."Id"
        JOIN BOM_CTE cte ON d."ChildProductId" = cte."ProductId"
        WHERE h."IsActive" = TRUE
    )
    SELECT * FROM BOM_CTE;
END;
$$ LANGUAGE plpgsql;



